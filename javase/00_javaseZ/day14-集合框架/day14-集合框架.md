# 1. List

## 1.1 集合框架类图

![image-20220424185652481](images\image-20220424185652481.png)

## 1.2 特性

![image-20220424185800630](images\image-20220424185800630.png)

## 1.3 List实现类

![image-20220424185850971](images\image-20220424185850971.png)

## 1.4 ArrayList

![image-20220424185940216](images\image-20220424185940216.png)

### 常用方法

![image-20220424190019820](images\image-20220424190019820.png)

![image-20220424190048475](images\image-20220424190048475.png)

![image-20220424190126710](images\image-20220424190126710.png)

### API

![image-20220424190156701](images\image-20220424190156701.png)

### 随堂练习1：

```
需求说明：
    把多个企鹅的信息添加到集合中
    查看企鹅的数量
    遍历所有企鹅的信息
    删除集合中部分企鹅的元素
    判断集合中是否包含指定企鹅 
```

## 1.5 LinkedList

![image-20220424190411045](images\image-20220424190411045.png)

## 1.6 Vector

```
线程安全
```

## 对比：

![image-20220424191514416](images\image-20220424191514416.png)

# 2. Map

## HashMap

### 常用方法

![image-20220424190445414](images\image-20220424190445414.png)

![image-20220424190535142](images\image-20220424190535142.png)

### API

![image-20220424190638466](images\image-20220424190638466.png)

### 随堂练习2：

```java
    Map map = new HashMap();
    map.put(1, "张三丰");
    map.put(2, "周芷若");
    map.put(3, "汪峰");
    map.put(4, "灭绝师太");

1.遍历集合，并将序号与对应人名打印。
2.向该map插入一个编码为5姓名为李晓
3.移除该map中的编号为1的信息
4.将map集合中编号为2的姓名信息修改为"周林"
```



### 随堂练习3：

```
有2个数组，
第一个省份数组内容为：
[黑龙江省,浙江省,江西省,广东省,福建省]，
第二个省会数组为：
[哈尔滨,杭州,南昌,广州,福州]，
将第一个数组元素作为key，第二个数组元素作为value存储到Map集合中。
如{黑龙江省=哈尔滨, 浙江省=杭州, …}。
```



### 随堂练习4：

```
定义一个泛型为String类型的List集合，统计该集合中每个字符（注意，不是字符串）出现的次数。 
	List list = ... 
例如：集合中有”abc”、”bcd”两个元素，
     list.add(“abc”)  ;    
     list.add(“bcd”) ;
程序最终输出结果为：“a = 1,b = 2,c = 2,d = 1”。    
  Map map = ...
   String 类  1.  length() 字母个数
              2.   charAt() 根据索引 获得 字母

```

### 随堂练习5：

```
需求说明：
 根据宠物昵称查找对应宠物，如果找到，显示宠物信息，否则给出错误提示 
Map
 key:   宠物名字 (唯一)
 value: Pet宠物对象 【Dog，Cat】
null ？
```



## Hashtable

```
null值问题?
```

## 对比：

![image-20220424191449662](images\image-20220424191449662.png)

# 3. Iterator

## 基本使用

![image-20220424191752185](images\image-20220424191752185.png)

![image-20220424191841510](images\image-20220424191841510.png)

### 随堂练习6

```
使用ArrayList和LinkedList存储多个企鹅信息，然后统一使用Iterator进行遍历 
```

# 4. 泛型

## 为什么

![image-20220424192006124](images\image-20220424192006124.png)

## 怎么用

![image-20220424192037339](images\image-20220424192037339.png)

![image-20220424192106503](images\image-20220424192106503.png)

# 5. Set

## 5.1 HashSet

![image-20220424192144146](images\image-20220424192144146.png)

### 随堂练习7

```
双色球规则：
双色球每注投注号码由6个红色球号码和1个蓝色球号码组成。
红色球号码从1—33中选择；
蓝色球号码从1—16中选择；
请随机生成一注双色球号码。
（要求同色号码不重复）
```
# 6. Map

## 6.1 Map练习

### 练习8

```java
一、利用Map，完成下面的功能：
从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。
如果该年没有举办世界杯，则输出：没有举办世界杯。
map.put(1930,"乌拉圭");
map.put(1934,"意大利");
map.put(1938,"意大利");
map.put(1950,"乌拉圭");
map.put(1954,"西德");
map.put(1958,"巴西");
map.put(1962,"巴西");
map.put(1966,"英格兰");
map.put(1970,"巴西");
map.put(1974,"西德");
map.put(1978,"阿根廷");
map.put(1982,"意大利");
map.put(1986,"阿根廷");
map.put(1990,"西德");
map.put(1994,"巴西");
map.put(1998,"法国");
map.put(2002,"巴西");
map.put(2006,"意大利");
map.put(2010,"西班牙");
map.put(2014,"德国");

```

### 练习9

```java
二、在原有世界杯Map 的基础上，
    增加如下功能： 
    	读入一支球队的名字，输出该球队夺冠的年份列表。 
    例如，
        读入“巴西”，应当输出 1958 1962 1970 1994 2002 
        读入“荷兰”，应当输出 没有获得过世界杯 
```

## 6.2 Map.Entry

![image-20220425211411275](images\image-20220425211411275.png)

## 6.3 Map综合练习

```java
站编号和站名对应关系如下：
1=朱辛庄
2=育知路
3=平西府
4=回龙观东大街
5=霍营
6=育新
7=西小口
8=永泰庄
9=林萃桥
10=森林公园南门
11=奥林匹克公园
12=奥体中心
13=北土城

```

### 练习10

```java
将以上对应关系的数据存储到map集合中，key：表示站编号，value：表示站名，并遍历打印(可以不按顺序打印)：
    例如：
       第10站: 森林公园南门
       第6站: 育新
       第12站: 奥体中心
       第13站: 北土城
```

### 练习11

```java
计算地铁票价规则：
    总行程 3站内（包含3站）收费3元，
    3站以上但不超过5站（包含5站）的收费4元，
    5站以上的，在4元的基础上，每多1站增加2元，
    10元封顶；
```

### 练习12

```java
打印格式（需要对键盘录入的上车站和到达站进行判断，如果没有该站，提示重新输入，直到站名存在为止）：
注意：每站需要2分钟
    请输入上车站：
    	朱辛庄
    请输入到达站：
   		 西小口
    从朱辛庄到西小口共经过6站收费6元，大约需要 12分钟
```

# 7.Set

## 7.1 TreeSet

![image-20220425211927973](images\image-20220425211927973.png)

## 7.2 练习13

```java
学生类  姓名 分数 double
  存放 TreeSet中
  实现 根据 分数 从大到小  内部排序
Set<Stu>  set = new TreeSet<>() ;
set.add(new Stu(“aa”,98.5)) ;
set.add(new Stu(“bb”,88.5)) ;
```

# 8. Collections

## 8.1 辅助类

![image-20220425212138509](images\image-20220425212138509.png)

## 8.2 练习14

```java
分别用Comparable和Comparator两个接口对下列四位同学的成绩做降序排序，
    如果成绩一样，那在成绩排序的基础上按照年龄由小到大排序。
```

![image-20220425212249416](images\image-20220425212249416.png)

# 9. 扩展

## 9.1 LinkedHashSet

![image-20220425212514027](images\image-20220425212514027.png)

## 9.2 LinkedHashMap

![image-20220425212553993](images\image-20220425212553993.png)

## 9.3 ConcurrentHashMap

![image-20220425212739744](images\image-20220425212739744.png)

## 9.4 Properties

![image-20220425212815266](images\image-20220425212815266.png)

# 10.泛型

## 10.1 什么是泛型

![image-20220425213010808](images\image-20220425213010808.png)

![image-20220425213040282](images\image-20220425213040282.png)

## 10.2 泛型好处

![image-20220425213114472](images\image-20220425213114472.png)

## 10.3 使用前后对比

![image-20220425213345463](images\image-20220425213345463.png)

![image-20220425213500007](images\image-20220425213500007.png)

## 10.4 类型参数

![image-20220425214125508](images\image-20220425214125508.png)

![image-20220425214149193](images\image-20220425214149193.png)

## 10.5 方法参数

![image-20220425214235909](images\image-20220425214235909.png)

![image-20220425214350680](images\image-20220425214350680.png)

![image-20220425214501978](images\image-20220425214501978.png)

![image-20220425214614120](images\image-20220425214614120.png)

## 10.6 泛型不是协变的

![image-20220425214656674](images\image-20220425214656674.png)

## 10.7 类型通配符

![image-20220425214746410](images\image-20220425214746410.png)

![image-20220425214810914](images\image-20220425214810914.png)

## 10.8 泛型局限性

![image-20220425214846267](images\image-20220425214846267.png)
