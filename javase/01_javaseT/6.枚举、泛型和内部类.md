# 枚举、泛型和内部类，主讲：汤小洋

## 一、枚举

### 1. 简介

​	枚举类型是JDK1.5引入的新类型，本质上就是一个类，是自定义的数据类型

​	作用：

- 用来限制可能的取值个数
- 降低出错的几率
- 提高代码的可读性和可扩展性

​        应用场景：适用于有限个数的取值

### 2. 用法

​	使用enum关键字（enumeration的缩写）

​        定义方式：`public enum 枚举类型名{}`

​	特性：

- 枚举类型中可以包含属性、方法、构造方法等
- 构造方法必须是私有的，不允许在外部创建对象，只能在内部创建对象
- 在内部创建枚举对象时必须位于类的第一行（非注释行）
- 在内部创建枚举对象时本质上是在调用构造方法，如果调用的是无参构造，可以省略()
- 可以创建多个枚举对象，多个对象之间以逗号隔开，以分号结束
- 枚举对象也称为枚举项，本质上是静态常量，通过`枚举类型名.枚举项`的方式访问，同时在命名上使用所有字母大写的形式	

## 二、泛型

### 1. 简介

​	Generic Type泛型本质是参数化类型，所操作的数据类型被指定为一个参数，在使用时确定此类型。

​	通俗点来说，在定义时不知道具体的类型，在使用时要指定具体的类型，类似于参数，所以称为参数化类型

​	分类：

- 泛型类
- 泛型接口
- 泛型方法

### 2. 用法

​       泛型类：

- 表示类中有一个未知的类型
- 定义方式：`public class 类名<T>{}`，T表示的是一种类型，是泛型的类型参数，可以使用任意标识，一般常用T、E、K、V等
- 可以在类内部使用T，表示一个对象的类型
- 在使用类时需要在类名后通过`<类型>`指定具体的类型
- 在JDK7中支持泛型的类型推断`类名<类型> 对象名=new 类名<>();`

​        泛型接口：

- 表示接口中有一个未知的类型
- 定义方式：`public interface 接口名<T>{}`
- 可以在接口内部使用T，表示一个对象的类型
- 在使用接口时需要在接口名后通过`<类型>`指定具体的类型

​         泛型方法：

- 表示方法中有一个未知的类型
- 定义方式：`public 修饰符 <T> 返回值类型 方法名(){}`
- 可以在方法中使用T，表示一个对象的类型
- 在调用方法时指定具体的类型
- 应用场景：如果类或接口没有定义成泛型，但是想在某个方法中使用泛型（如接收了一个泛型参数），此时可以将该方法定义为泛型方法

​        特性：

- 泛型的类型参数必须是引用类型，不能是基本类型

- 泛型的类型参数可以有多个，即多个泛型参数

- 可以使用泛型通配符，两种：

  <? extends T>限定类型的上界，参数类型必须是T或T的子类

  <? super T> 限定类型的下界，参数类型必须是T或T的父类

## 三、内部类

### 1. 简介

​	定义在另一个类里面的类，称为内部类Inner Class

​	包含内部类的类，称为外部类Outer Class

​	分类：

1. 成员内部类（非静态内部类）
2. 局部内部类
3. 静态内部类
4. 匿名内部类，最常用

### 2. 用法

#### 2.1 成员内部类

​	在外部类中访问内部类：可以访问内部类中的所有成员，包括private修饰的

​	在外部类外访问内部类：不能访问内部类中private修饰的成员

​	在内部类中访问外部类：直接访问，如果外部类和内部类的变量名相同，可使用"外部类.this.变量"访问	

#### 2.2 局部内部类

​	局部内部类，也称为方法内部类，即定义在外部类的方法中的类

- 只能在外部类的方法中使用
- 在jdk1.8以前，在局部内部类中不能访问外部类的方法中非final修饰的变量
- 在jdk1.8及以后，外部类的方法中非final修饰的变量也可以被访问，其实是一种语法溏，本质上会自动将变量变为final的	

#### 2.3 静态内部类

​	静态内部类，使用static修饰的成员内部类

​	不能访问外部类中的非静态成员

#### 2.4 匿名内部类

​	匿名内部类，即没有名字的内部类，因为此类只需要使用一次，所以没有起名字的必要，太麻烦

​	在创建匿名内部类时必须作为new语句的一部分来声明

​	用法：

```java
接口/类 对象名=new 接口/类(){
	//匿名内部类
}
```





